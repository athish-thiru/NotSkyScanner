-> The output and correctness of each algorithm – You should summarize, visualize, or highlight some part of the full-scale run of each algorithm. Additionally, the report should briefly describe what tests you performed to confirm that each algorithm was working as intended.

The algorithms used in our project consisted of the following:

Breadth First Search: It was declared in Graph.h (std::vector<std::string> BFS(int source_number);) and implemented in Graph.cpp. We used the BFS algorithm to traverse through our graph. It required the source number of the airport as the argument of the function and used a queue and a bool vector to keep track of nodes that had already been visited. This algorithm has time complexity O(V+E) where V is the number of nodes and E is the number of edges. Breadth first search for a graph can end up being cyclical and to avoid that happening, we mark vertices as visited and unvisited. For our database with 67663 routes between 3321 airports on 548 airlines, this was a massive traversal and big-O efficiency was essential. The tests for this algorithm are located in testBFS.cpp/tests/NotSkyScanner. They use test datasets, testAirports.dat and testRoutes.dat to test the information at the specified source number. If the expected value matches the actual value in the datasets parsed, then the algorithm works correctly. Running these tests shows us that our implementation is actually correct, since all tests are passed. 

Dijkstra’s Algorithm: Dijkstra’s algorithm helps calculate the shortest path between any 2 airports. It is declared in Graph.h (vector< pair<int, int> > Graph::Dijkstra(int start,int destination);) and implemented in Graph.cpp. It required the start and destination airports to utilize a priority queue where every item of the priority queue is a pair of the vertex weight of the edge being looked at starting from that vertex. The function returns the shortest distance vector. It has a time complexity of O(ElogV). 

Betweenness Centrality: Betweenness Centrality is a very practical algorithm that helps us arrive at a conclusion about the airport which has the most number of shortest paths linked to it. It is a way to effectively “rank” airports based on data obtained from Dijkstra’s algorithm. It takes int size as the argument of the function and returns a vector of floats, bc_node. A vector of ints of the size of the airports vector is kept, and Dijkstra’s is run between every two possible nodes in the graph. This gives us a vector storing the number of shortest paths that each airport appears in. Every time a node appears in the shortest path between two nodes, its frequency count is incremented by 1. Using the betweenness centrality formula [number of pairs given by: size of graph or number of nodes in it*(size of graph-1)/2] betweenness centrality score is calculated using frequency of the node/(number of pairs). The time complexity of this algorithm equals O(nm). The tests for this algorithm have been included in testsBC/tests/NotSkyScanner. 

 
-> The answer to your leading question – You should direct address your proposed leading question. How did you answer this question? What did you discover? If your project was ultimately unsuccessful, give a brief reflection about what worked and what you would do differently as a team.

Answer: Our project proposal outlined the leading question as follows:

“The data set that we have decided to use is the Open Flights database, which is an open-source data set of flight routes and airports. We plan to use this data to create a directed graph and use the distance between two airports as the weight for the edges. Finally, we will use this data to determine the shortest distance between any two airports using Dijkstra's algorithm. We will then use the Betweenness Centrality algorithm to determine which airport has the most number of shortest routes. Note that only those paths will be considered where an actual airline route operates.“

In short, we wanted to find a method to find the shortest path between any two airports, and determine the most efficient route to fly between two locations. 

For this purpose, we first parsed the given datasets, airports.dat and routes.dat, and stored our data in a graph built using an adjacency list. This was done in the routes.cpp file to push_back elements into the destination id and source id vectors after parsing routes.dat. The distance between two airports was calculated using the distance function and stored in the distance vector and finally by using the set_vector function we created a vector of Airports. set_vector parsed airports.dat to store the name, city, latitude, longitude and IATA information for each airport. The graph was then created in Graph.cpp using the addEdge and addAllEdges functions to create an adjacency list using our vectors with stored data.  

We used BFS and Dijkstra’s algorithm to traverse the graph and find the shortest path between any two vertices. BFS was implemented using a queue to push and pop data and mark vertices as visited. Dijsktra’s algorithm is implemented using a heap/priority queue (referred: https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/). The outcome of these algorithms fulfilled the purpose of our project, and then the Betweenness Centrality algorithm was used to “rank” the airports by the number of shortest paths associated with each. All algorithms were implemented in Graph.cpp. 

We discovered that there are multiple implementations of solving the shortest path problem by Dijkstra’s algorithm, and one can even use sets for this purpose. Our project was ultimately successful, and we learnt a lot about correct methods of parsing, data storage and traversal.

